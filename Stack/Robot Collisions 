// as this is the same question as the aesteroid collision and 
// just one thing to make sure that sorting the index and the postion accoridingly
// so here there are some if the cases
 // 1 ->>   if we got the direction R then push that in the stack 
 // 2->>    and of we got the "L" it maen that we are getting the oppsite robot which can collide to the "R"  
//         1->> IF we got the left
                check these conditions like 
                !!!!  current health and the top health greater and smaller 
                !!!!  and maintian the boolean pointer accordinlgy

                handling edge case
                ->> if LRRLL
                    here the first L will surview likewise




class Solution {
    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths, String directions) {
        int n = positions.length;
        Integer index [] = new Integer [n];

        for (int i=0;i<n;i++){
            index[i] = i;
        }
        // Arrays.sort(index, new Comparator<Integer>(){
        //     public int compare(Integer a, Integer b){
        //         return positions[a] - positions[b];
        //     }
        // });

        Arrays.sort(index , (a,b) -> positions[a] - positions[b]);

        Stack<Integer> st = new Stack<>();

        for (int i=0;i<n;i++){
            int curr  = index[i];
            if(directions.charAt(curr) == 'R'){
                st.push(curr);
            }
            else {
                boolean surview = true;
                while (!st.isEmpty()){

                    int top =st.peek();

                    if(directions.charAt(top) ==  'L'){
                        surview = true;
                        break;
                    }

                     else if(healths[curr] > healths[top]){
                        surview= true;
                        healths[top] = 0;
                        healths[curr] -= 1;
                        st.pop();
                    }

                    else if (healths[curr] < healths[top]){
                        surview = false;
                        healths[curr] = 0;
                        healths[top] -= 1;
                        break;
                        
                    }

                    else {
                        // both are same
                        surview = false;
                        healths[curr] =0;
                        healths [top] =0;
                        st.pop();
                        break;
                    }

                }
                if(surview) st.push(curr);
            }


        }
        List<Integer> ans = new ArrayList<>();

        for (int i=0;i<n;i++){
            if (healths[i] >0) ans.add(healths[i]);
        }
        return ans;
    }
}